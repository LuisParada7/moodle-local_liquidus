{"version":3,"file":"router.min.js","sources":["../src/router.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Liquidus Router module. Routes events to trackers.\n *\n * @copyright Copyright (c) 2020 Open LMS\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine(['jquery', 'core/log', 'core/ajax', 'core/notification'],\nfunction($, Log, ajax, notification) {\n\n    const self = this;\n\n    self.trackers = [];\n\n    self.eventDefArray = [];\n\n    self.initRun = false;\n\n    self.eventsLoaded = false;\n\n    self.registerTracker = function(tracker) {\n        Log.debug(`[${tracker.trackerInfo.trackerId}] Registering tracker`);\n        self.trackers[tracker.trackerInfo.trackerId] = tracker;\n\n        // Send initial tracker events.\n        tracker.identify();\n        tracker.trackPage();\n        if (tracker.heartBeat) {\n            setInterval(tracker.heartBeat, 10000); // Heart beat.\n        }\n        self.addEventTracking(tracker.trackerInfo.trackerId);\n    };\n\n    self.init = function() {\n        const dfd = $.Deferred();\n        if (self.initRun) {\n            self.whenTrue(() => {\n                return self.eventsLoaded;\n            }, () => {\n                dfd.resolve();\n            }, true);\n            return dfd;\n        }\n        self.initRun = true;\n\n        const promises = ajax.call([\n            {\n                methodname: 'local_liquidus_event_definition', args: {}\n            },\n        ]);\n\n        $.when(...promises).done(function(data) {\n            data.forEach((trackerDef) => {\n                self.eventDefArray[trackerDef.provider] = trackerDef;\n            });\n            self.eventsLoaded = true;\n            dfd.resolve();\n        }).fail(function(ex) {\n            notification.exception(ex);\n            dfd.resolve();\n        });\n\n        return dfd;\n    };\n\n    self.addEventTracking = function(trackerId) {\n        const trackerDef = self.eventDefArray[trackerId];\n        if (typeof trackerDef === 'undefined') {\n            Log.debug(`[${trackerId}] No custom events configured.`);\n            return;\n        }\n        const tracker = self.trackers[trackerId];\n        trackerDef.definition.forEach((eDef) => {\n            Log.debug(`[${trackerDef.provider}] Looking for selector: ${eDef.testselector}`);\n            if ($(eDef.testselector).length) {\n                self.processDefinition(tracker, eDef);\n            }\n        });\n    };\n\n    self.processDefinition = (tracker, edef) => {\n        const trackerId = tracker.trackerInfo.trackerId;\n        Log.debug(`[${trackerId}] Adding event handling for custom event: ${edef.selector} -> ${edef.event}`);\n        $(edef.selector).on(edef.event, function(evt) {\n            evt.preventDefault();\n\n            const parentNode = $(this);\n\n            Log.debug(`[${trackerId}] Tracking custom event: ${edef.selector} -> ${edef.event}`);\n\n            var data = {};\n\n            for (let i in edef.data) {\n                const ddef = edef.data[i];\n                Log.debug(`[${trackerId}] Looking for '${ddef.selector}' value.`);\n                const ddefNode = parentNode.find(ddef.selector);\n                if (ddefNode.length > 0) {\n                    Log.debug(`[${trackerId}] Selector '${ddef.selector}' value.`);\n                    ddefNode.each(function(index) {\n                        const dataNode = $(this);\n\n                        let id = dataNode.attr('id');\n                        if (typeof id === 'undefined') {\n                            id = dataNode.attr('name');\n                        }\n\n                        if (typeof id === 'undefined') {\n                            id = index;\n                        } else {\n                            id = index + '_' + id;\n                        }\n\n                        data[ddef.name + '_' + id] = null;\n\n                        let value;\n                        if (ddef.type === 'input') {\n                            value = dataNode.val();\n                        } else {\n                            value = dataNode.text();\n                        }\n                        if (typeof value !== 'undefined' && value !== '' && value !== null) {\n                            data[ddef.name + '_' + id] = value;\n                        }\n                    });\n                }\n\n            }\n\n            const dfd = $.Deferred();\n            tracker.processEvent(dfd, edef.name, data);\n\n            // Forcefully resolve the promise if it hasn't been already.\n            // This guarantees that the process is not stalled.\n            setTimeout(() => {\n                if (dfd.state() === 'pending') {\n                    Log.debug(`[${trackerId}] Failed to send data for: ${edef.selector} -> ${edef.event}`);\n                    dfd.resolve();\n                }\n            }, 1000);\n\n\n            dfd.then(() => {\n                Log.debug(`[${trackerId}] Processed: ${edef.selector} -> ${edef.event}, proceeding with event.`);\n                $(edef.selector).off(edef.event);\n                $(edef.selector).trigger(edef.event);\n            });\n        });\n    };\n\n    /**\n     * On function evaluating true.\n     *\n     * @param {function} func\n     * @param {function} callBack\n     * @param {boolean} forceCallBack\n     * @param {number} maxIterations\n     * @param {number} i\n     */\n    self.whenTrue = (func, callBack, forceCallBack, maxIterations, i) => {\n        maxIterations = !maxIterations ? 10 : maxIterations;\n        i = !i ? 0 : i + 1;\n        if (i > maxIterations) {\n            // Error, too long waiting for function to evaluate true.\n            if (forceCallBack) {\n                callBack();\n            }\n            return;\n        }\n        if (func()) {\n            callBack();\n        } else {\n            window.setTimeout(() => {\n                self.whenTrue(func, callBack, forceCallBack, maxIterations, i);\n            }, 200);\n        }\n    };\n\n    return {\n        'init': self.init,\n        'registerTracker': self.registerTracker\n    };\n});\n"],"names":["define","$","Log","ajax","notification","self","this","trackers","eventDefArray","initRun","eventsLoaded","registerTracker","tracker","debug","trackerInfo","trackerId","identify","trackPage","heartBeat","setInterval","addEventTracking","init","dfd","Deferred","whenTrue","resolve","promises","call","methodname","args","when","done","data","forEach","trackerDef","provider","fail","ex","exception","definition","eDef","testselector","length","processDefinition","edef","selector","event","on","evt","preventDefault","parentNode","i","ddef","ddefNode","find","each","index","dataNode","value","id","attr","name","type","val","text","processEvent","setTimeout","state","then","off","trigger","func","callBack","forceCallBack","maxIterations","window"],"mappings":"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"}